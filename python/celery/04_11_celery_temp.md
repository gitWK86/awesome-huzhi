# Celery-4.1 用户指南: Security

翻译[libing_thinking](https://me.csdn.net/u013148156) 最后发布于2017-11-22 12:46:00 阅读数 596 收藏

展开

## 简介

------

虽然Celery 编写的时候考虑了安全，但是它仍然应该认为是一个不安全的组件。

依据安全策略，你可以采取几个步骤使得你的 Celery 安装更加安全。

## 关注的领域

------

### 消息中间件

------

保障消息中间件不受不想要的访问是必须的，特别当它可以从外面访问时。默认情况下，工作单元确信他们从消息中间件后去的数据没有被篡改过。查看消息签名这一节获取更多如何使消息中间件连接更可信的信息。

第一道防御应该是在消息中间件前面放置一道防火墙，使得只允许白名单机器能访问。

记住防火墙配置错误和临时禁用防火墙在显示世界都是经常可见的。牢固的安全策略包含对防火墙设备的监控，以确认他们是否已经被禁用，而禁用可能是偶然的或者是刻意的。

换而言之，不应该盲目的相信防火墙。

如果的你消息中间件支持细粒度的访问控制，如 RabbitMQ，这是你应该考虑的。查看 `http://www.rabbitmq.com/access-control.html` 中示例。

如果你的消息中间件支持，你可以通过使用 `broker_user_ssl` 启用端对端的 SSL 加密以及授权认证。

### 客户端

------

在 Celery 中， “客户端”指任何向消息中间件发送消息的实体，例如发起任务的web服务器。

如果任意的消息都可以通过客户端的发送，那么保障消息中间件的安全也起不到作用。

[Need more text here]

### 工作单元

------

在一个工作单元里执行的任务的权限与工作单元本身的权限相同。这包括下列这些资源的权限：内存，文件系统以及设备。

有一个特例除外，就是当前默认使用的基于 `multiprocessing` 的任务池。在这种情况下，任务将会有访问 `fork()` 复制出来的内存的访问权限，以及同一个工作单元子进程中父任务写的内存内容的访问权限。

限制内存内容的访问可以通过在一个子进程 (`fork()+execve()`)中启动每个任务来达到效果。

限制文件系统和设备的访问可以通过使用 `chroot,jail,sandboxing, virtual machines` 或者其它被平台和附加软件使能的机制。

还要注意任意在工作单元上执行的任务与运行所在的机器有相同的网络访问权限。如果工作单元在以一个内部网络，那么建议给出去的流量添加防火墙规则。

## 序列化器

------

从4.0版本开始，默认的序列化器时 JSON，但是因为它支持的数据类型有限，你可能会想考虑使用 pickle 来做序列化。

pickle 序列化器非常方便，它可以序列化几乎所有python对象，甚至是函数，但是基于同样的原因，pickle 是不安全的，并且当客户端不可信或者没授权时应该避免使用。

你可以通过使用 `accept_content` 设置声明一个可接受内容类型的白名单来拒绝不安全的内容：

3.0.18版本新特性。

注意：
这个设置首先在 3.0.18 版本被支持。如果你使用的是一个以前的版本，可以忽略它，所以请确保你使用了一个支持该特性的版本。

```
accept_content = ['json']1
```

它接受一个序列化器名称及内容类型的列表，所以你可以为json声明内容类型：

```
accept_content = ['application/json']1
```

Celery 带有一个特殊的 `auth` 序列化器，它用来验证客户端和工作单元之间的通信，确保消息来自可信的源。使用 `Pulic-key cryptography`，`auth` 序列化器能够验证发送者的权限，要启用这个特性，请阅读消息签名获取更多的信息。

## 消息签名

------

利用 `pyOpenSSL` 库，Celery 可以使用`Public-key cryptography`来对消息签名，被客户端发送的消息会使用一个私钥签名，工作单元接收到之后会使用公钥进行验证。

优化的证书应该是一个正式的证书授权机构签发的，但是他们也可以自签名。

你可以通过配置 `task_serializer` 设置来使用 `auth` 序列化器。这同时还需要配置寻找文件系统中私钥和证书的路径：`security_key, security_certificate` 以及 `security_cert_store`。使用了这些配置，还需要调用 `celery.setup_security()` 函数。注意这也会禁用所有不安全的序列化器使得工作单元不会接受不可信内容类型的消息。

以下是一个使用 `auth` 序列化器的配置示例，使用 `/etc/ssl` 中的私钥和证书。

```
app = Celery()
app.conf.update(
    security_key='/etc/ssl/private/worker.key'
    security_certificate='/etc/ssl/certs/worker.pem'
    security_cert_store='/etc/ssl/certs/*.pem',
)
app.setup_security()1234567
```

注意：
使用相对路径是不允许的，建议使用绝对路径。

另外，注意`auth`序列化器不会加密消息的内容，如果需要这必须另外使能。

## 入侵检测

------

防御你的系统使其免遭入侵的最重要的部分是能够探测到你的系统是否已经损坏。

### 日志

------

日志通常是记录安全问题证据的第一个地方，但是如果他们可以被篡改就没有什么用了。

一个好的方案是使用一个专门的日志服务器来进行中央化的日志管理。对它的访问应该受限。除了可以将所有的日志存储在一个地方，如果配置正确，它还可以使入侵者很难篡改你的日志。

使用 `syslog`，这将非常容易实现（查看syslog-ng 以及 rsyslog）。Celery 使用 `logging` 库，并且已经对 syslog 有支持。

给偏执狂的一个提示是使用 UDP 发送日志，并且切断日志服务器网络电缆的传输部件。

### Tripwire

------

Tripwire 是一个数据完整性检测工具（现在是商业化的），有几个开源的实现，用来加密文件系统中文件的哈希值，所以当他们被修改时管理员能收到告警。使用它，当灾难已经造成并且你的系统已经被损坏，你可以知道入侵者修改了哪些文件（密码文件，日志，back-doors，root-kits 等等）。通常这是你探测入侵的唯一方式。

一些开源的实现包括：
\- OSSEC
\- Samhain
\- Open Source Tripwire
\- AIDE

另外，`ZFS`文件系统带有一个内建的完整性检测机制。

### Footnotes

------







https://blog.csdn.net/u013148156/article/details/78599617